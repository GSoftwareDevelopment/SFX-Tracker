# SFX ENGINE

TABLE OF CONTENT
----------------------------------------------------

Hardware registers
---
Important things  
  - Custom SFX engine extensions  
  - Modulator section

Software registers
---

Zero page registers  
  - SFX Tick-Loop registers  
  - Temporary storage for hardware registers  
Channels registers

SFX_Engine UNIT
---

What it offers?  
  - `INIT_SFXEngine`  
  - `SetNoteTable`  
  - `SFX_Start`  
  - `SFX_ChannelOff`  
  - `SFX_Off`  
  - `SFX_Note`  
  - `SFX_End`  
  
Engine Customization  
  - Conditional Compilation Labels  
    `SFX_SWITCH_ROM`  
    `SFX_previewChannels`  
    `USE_MODULATORS`  
      `DFD_MOD`  
      `LFD_NLM_MOD`  
      `MFD`  
      `HFD`  
    ~~`USE_ALL_MODULATORS`~~  
	`CALC_ABS_SFX_ADDR`
  - Operation mode without modulator section

-------------------------------------------------------------------------

## Hardware registers

In the SFX engine procedure, hardware registers are strictly assigned to specific functions.

| Register | Description    |
|:--------:|:---------------|
| X        | channel offset |
| Y        | SFX offset     |
| A        | General data   |

### Important things

#### Custom SFX engine extensions

If you want to use them, take care to store their state in the temporary _regX & _regY registers located on page zero before using them.

#### Modulator section

If you want to create your own kind of modulator, you should keep in mind the output parameter.

The section must returns a parameter in this register and this is the value of the frequency divider for the POKEY circuit (frequency).

-------------------------------------------------------------------------

## Software registers

### Zero page registers

#### SFX Tick-Loop registers

These registers are used Only in the _SFX Tick-Loop_ and store information about the currently playing channel.

| Register name | ZP addr | Description                      |
|:--------------|:-------:|:---------------------------------|
| sfxPtr        | $F5,$F6 | SFX Pointer                      |
| chnNote       | $F7     | SFX Note                         |
| chnFreq       | $F8     | SFX Frequency                    |

Below parameters can be accessed by using the [conditional compilation labels](./SFX-Engine.md#conditional-compilation-labels).

| Register name | ZP addr | Description                  |
|:--------------|:-------:|:-----------------------------|
| chnMode       | $F9     | SFX modulation Mode              |
| chnMod        | $FA     | SFX Modulator value*         |
| chnCtrl       | $FB     | SFX distortion & volume      |         

_*_ in most cases contains a function and a value. Usually the oldest bits of this parameter describe the function. The rest is the value.

#### Temporary storage for hardware registers

| Register name | ZP addr | Description                  |
|:--------------|:-------:|:-----------------------------|
| _regTemp      | $FC     | temporary store for reg A    |

### Channels registers

This is an array that describes the state of all 4 channels that the SFX Engine supports.

| Register name | relative addr | Description                  |
|:--------------|:-------------:|:-----------------------------|
| sfxPtr        | chnOfs+0      | SFX Pointer                  |
| chnOfs        | chnOfs+2      | SFX Offset in SFX definition |
| chnNote       | chnOfs+3      | SFX Note                     |
| chnFreq       | chnOfs+4      | SFX Frequency                |

Below parameters can be accessed by using the [conditional compilation labels](./SFX-Engine.md#conditional-compilation-labels).

| Register name | relative addr | Description                  |
|:--------------|:-------------:|:-----------------------------|
| chnMode       | chnOfs+5      | SFX Modulation Mode          |
| chnMod        | chnOfs+6      | SFX Fn & Modulator value     |
| chnCtrl       | chnOfs+7      | SFX Distortion & Volume      |

The memory location for this array is determined by the `SFX_CHANNELS_ADDR` constant in the _INTERFACE_ SFX_ENGINE UNIT section

__The required space is 32 bytes__.

-------------------------------------------------------------------------

## SFX_Engine UNIT

### What it offers?

- __INIT_SFXEngine__

`INIT_SFXEngine(_SFXModModes, _SFXList, _TABList, _SONGData:word);`

Engine Initialization. Specify the memory map:

`_SFXModModes` - an array of modulation modes for each SFX

`_SFXList` - an array of pointers for SFX definitions*

`_TABList` - an array of indicators (relative for now) for TAB definitions

`_SONGData` - array of TAB layouts

__Why relative values?__

TODO: CALC_ABS_SFX_ADDR
Because it still works with HEAP, and it operates on an array `array[0..0] of byte`, which it assigns (via `ABSOLUTE`) a place in memory.

- __SetNoteTable__

`SetNoteTable(_note_val:word);`

Sets the memory location `_note_val` for the definition of the note table.
Its layout is linear, i.e. 0 is note C-0, 1 is C#0, 2 is D-0, etc...
Up to a maximum of 64 notes.

- __SFX_Start__

`SFX_Start();`

Start the SFX engine.

- __SFX_ChannelOff__

`SFX_ChannelOff(channel:byte);`

It turns off the current SFX playing in the specified channel.

- __SFX_Off__

`SFX_Off();`

Here similar to `SFX_ChannelOff`, only for all channels.
This routine is fired during SFX engine shutdown (procedure `SFX_End()`).

- __SFX_Note__

`SFX_Note(channel,note,SFXId:byte);`

`channel` - the channel on which SFX will be played

`note` - a note (see `SetNoteTable` note table initialization)

`SFXId` - Index of the SFX definition.

- __SFX_End__

`SFX_End();`

Disabling the SFX engine.

## Engine Customization

The __SFX-Engine__ allows you to customize your code to suit your needs. A number of compilation directives allow you to choose the features you want to use in your program.

### Conditional Compilation Labels

- `SFX_SWITCH_ROM`

Defining this label allows access to the RAM "covered" by the ROM. The definition works with the ROMOFF label in __MAD Pascal__, which allows RAM to be used in this area.

- `SFX_previewChannels`

An option that generates a small amount of code, providing the ability to view the current state of the modulator and the distortion and volume values, by transferring from the main loop (_SFX_TICK_) the changes made by the engine to the channel registers.

Additional information is placed in the `CHANNELS` table at offsets 6 and 7 of each channel (see at [Channels registers](./SFX-Engine.md#channels-registers)).

The absence of this definition, frees an additional two bytes on the null page.

- `CALC_ABS_SFX_ADDR`

TODO

- `USE_MODULATORS`

This complex label Must be defined to select supported modulation modes. Its absence at compile time, causes [operation without modulator section](./#mode-operation-without-modulator-section)

No modulator section frees one byte on the zero page.

The presence of the following labels during compilation, create the corresponding code:

  - `DFD_MOD` - Direct Frequency Divider Modulation section.	
  - `LFD_NLM_MOD` - Low Frequency Divider/Note Level Modulator section	
  - `MFD` - Middle Frequency Divider	
  - `HFD` - High Frequency Divider
	
For more on modulation, see [Modulation types](./modval_EN.md)

- ~~`USE_ALL_MODULATORS`~~

~~Forces the use of all supported modulators, regardless of the state of the `USE_MODULATORS` declaration and its subordinates.~~

### Operation mode without modulator section

This is the simplest possible version of the SFX engine.

The SFX definition in this mode, occupies a maximum of 127 bytes and there is only one byte per step.

When operating without a modulator section, the length of the definition is contained in the `SFXModModes` modulation mode array. To use this mode of operation in the `SFXModModes` SFX array index, bit 7 must be set and the rest of the bits indicate length.

> In modulation mode, the end of the SFX definition is checked during its "execution" and is determined by the SFX-STOP function, so it is not required to "keep" its length in a separate array. This solution minimizes memory usage, at the expense of having to pay special attention to the use of the `JUMP_TO` function, since there is no way to quickly check that the jump location does not exceed the definition limit - which can result in a program crash.
